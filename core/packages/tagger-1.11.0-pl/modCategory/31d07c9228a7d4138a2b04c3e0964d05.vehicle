<?php return array (
  'unique_key' => 'category',
  'preserve_keys' => false,
  'update_object' => true,
  'related_objects' => 
  array (
    'Snippets' => 
    array (
      '8de8f46977f8d9965b6bcc0721f86651' => 
      array (
        'preserve_keys' => false,
        'update_object' => true,
        'unique_key' => 'name',
        'class' => 'modSnippet',
        'object' => '{"id":null,"source":0,"property_preprocess":0,"name":"TaggerGetTags","description":"","editor_type":0,"category":0,"cache_type":0,"snippet":"\\/**\\n * TaggerGetTags\\n *\\n * DESCRIPTION\\n *\\n * This Snippet allows you to list tags for resource(s), group(s) and all tags\\n *\\n * PROPERTIES:\\n *\\n * &resources           string      optional    Comma separated list of resources for which will be listed Tags\\n * &parents             string      optional    Comma separated list of parents for which will be listed Tags\\n * &groups              string      optional    Comma separated list of Tagger Groups for which will be listed Tags\\n * &rowTpl              string      optional    Name of a chunk that will be used for each Tag. If no chunk is given, array with available placeholders will be rendered\\n * &outTpl              string      optional    Name of a chunk that will be used for wrapping all tags. If no chunk is given, tags will be rendered without a wrapper\\n * &separator           string      optional    String separator, that will be used for separating Tags\\n * &limit               int         optional    Limit number of returned tag Tags\\n * &offset              int         optional    Offset the output by this number of Tags\\n * &totalPh             string      optional    Placeholder to output the total number of Tags regardless of &limit and &offset\\n * &target              int         optional    An ID of a resource that will be used for generating URI for a Tag. If no ID is given, current Resource ID will be used\\n * &showUnused          int         optional    If 1 is set, Tags that are not assigned to any Resource will be included to the output as well\\n * &showUnpublished     int         optional    If 1 is set, Tags that are assigned only to unpublished Resources will be included to the output as well\\n * &showDeleted         int         optional    If 1 is set, Tags that are assigned only to deleted Resources will be included to the output as well\\n * &linkCurrentTags     int         optional    If 1 is set, Current Tags will be included in generated URL, default behavior is to generate links to a single tag\\n * &linkOneTagPerGroup  int         optional    If 1 is set, Only one tag will be placed to a group (in the URI tags from same group will swap places); Only available for linkCurrentTags=1; Default: 0\\n * &contexts            string      optional    If set, will display only tags for resources in given contexts. Contexts can be separated by a comma\\n * &toPlaceholder       string      optional    If set, output will return in placeholder with given name\\n * &sort                string      optional    Sort options in JSON. Example {\\"tag\\": \\"ASC\\"} or multiple sort options {\\"group_id\\": \\"ASC\\", \\"tag\\": \\"ASC\\"}\\n * &friendlyURL         int         optional    If set, will be used instead of friendly_urls system setting to generate URL\\n * &linkTagScheme       int|string  optional    Strategy to generate URLs, available values: -1, 0, 1, full, abs, http, https; Default: link_tag_scheme system setting\\n *\\n * USAGE:\\n *\\n * [[!TaggerGetTags? &showUnused=`1`]]\\n *\\n *\\n * @package tagger\\n *\\/\\n\\n\\/** @var Tagger $tagger *\\/\\n$tagger = $modx->getService(\'tagger\',\'Tagger\',$modx->getOption(\'tagger.core_path\',null,$modx->getOption(\'core_path\').\'components\\/tagger\\/\').\'model\\/tagger\\/\',$scriptProperties);\\nif (!($tagger instanceof Tagger)) return \'\';\\n\\n$resources = $modx->getOption(\'resources\', $scriptProperties, \'\');\\n$parents = $modx->getOption(\'parents\', $scriptProperties, \'\');\\n$groups = $modx->getOption(\'groups\', $scriptProperties, \'\');\\n$target = (int) $modx->getOption(\'target\', $scriptProperties, $modx->resource->id, true);\\n$showUnused = (int) $modx->getOption(\'showUnused\', $scriptProperties, \'0\');\\n$showUnpublished = (int) $modx->getOption(\'showUnpublished\', $scriptProperties, \'0\');\\n$showDeleted = (int) $modx->getOption(\'showDeleted\', $scriptProperties, \'0\');\\n$linkCurrentTags = (int) $modx->getOption(\'linkCurrentTags\', $scriptProperties, \'0\');\\n$linkOneTagPerGroup = (int) $modx->getOption(\'linkOneTagPerGroup\', $scriptProperties, \'0\');\\n$contexts = $modx->getOption(\'contexts\', $scriptProperties, \'\');\\n$translate = (int) $modx->getOption(\'translate\', $scriptProperties, \'0\');\\n\\n$defaultRowTpl = $modx->getOption(\'rowTpl\', $scriptProperties, \'\');\\n$outTpl = $modx->getOption(\'outTpl\', $scriptProperties, \'\');\\n$wrapIfEmpty = $modx->getOption(\'wrapIfEmpty\', $scriptProperties, 1);\\n$separator = $modx->getOption(\'separator\', $scriptProperties, \'\');\\n$limit = intval($modx->getOption(\'limit\', $scriptProperties, 0));\\n$offset = intval($modx->getOption(\'offset\', $scriptProperties, 0));\\n$totalPh = $modx->getOption(\'totalPh\', $scriptProperties, \'tags_total\');\\n\\n$weight = (int) $modx->getOption(\'weight\', $scriptProperties, \'0\');\\n\\n$friendlyURL = (int) $modx->getOption(\'friendlyURL\', $scriptProperties, $modx->getOption(\'friendly_urls\', null, 0));\\n$linkTagScheme = $modx->getOption(\'linkTagScheme\', $scriptProperties, $modx->getOption(\'link_tag_scheme\', null, -1));\\n\\n$sort = $modx->getOption(\'sort\', $scriptProperties, \'{}\');\\n$sort = $modx->fromJSON($sort);\\nif ($sort === null || $sort == \'\' || count($sort) == 0) {\\n    $sort = array(\\n        \'tag\' => \'ASC\'\\n    );\\n}\\n\\n$resources = $tagger->explodeAndClean($resources);\\n$parents = $tagger->explodeAndClean($parents);\\n$groups = $tagger->explodeAndClean($groups);\\n$contexts = $tagger->explodeAndClean($contexts);\\n$toPlaceholder = $modx->getOption(\'toPlaceholder\', $scriptProperties, \'\');\\n\\n$c = $modx->newQuery(\'TaggerTag\');\\n\\n$c->leftJoin(\'TaggerTagResource\', \'Resources\');\\n$c->leftJoin(\'TaggerGroup\', \'Group\');\\n$c->leftJoin(\'modResource\', \'Resource\', array(\'Resources.resource = Resource.id\'));\\n\\nif (!empty($parents)) {\\n    $c->where(array(\\n        \'Resource.parent:IN\' => $parents,\\n    ));\\n}\\n\\nif (!empty($contexts)) {\\n    $c->where(array(\\n        \'Resource.context_key:IN\' => $contexts,\\n    ));\\n}\\n\\nif ($showUnpublished == 0) {\\n    $c->where(array(\\n        \'Resource.published\' => 1,\\n        \'OR:Resource.published:IN\' => null,\\n    ));\\n}\\n\\nif ($showDeleted == 0) {\\n    $c->where(array(\\n        \'Resource.deleted\' => 0,\\n        \'OR:Resource.deleted:IS\' => null,\\n    ));\\n}\\n\\nif ($showUnused == 0) {\\n    $c->having(array(\\n        \'cnt > 0\',\\n    ));\\n}\\n\\nif (!empty($resources)) {\\n    $c->where(array(\\n        \'Resources.resource:IN\' => $resources\\n    ));\\n}\\n\\nif ($groups) {\\n    $c->where(array(\\n        \'Group.id:IN\' => $groups,\\n        \'OR:Group.name:IN\' => $groups,\\n        \'OR:Group.alias:IN\' => $groups,\\n    ));\\n}\\n$c->select($modx->getSelectColumns(\'TaggerTag\', \'TaggerTag\'));\\n$c->select($modx->getSelectColumns(\'TaggerGroup\', \'Group\', \'group_\'));\\n$c->select(array(\'cnt\' => \'COUNT(Resources.tag)\'));\\n$c->groupby($modx->getSelectColumns(\'TaggerTag\', \'TaggerTag\') . \',\' . $modx->getSelectColumns(\'TaggerGroup\', \'Group\'));\\n\\n$c->prepare();\\n\\n$countQuery = new xPDOCriteria($modx, \\"SELECT COUNT(*) as total, MAX(cnt) as max_cnt FROM ({$c->toSQL(false)}) cq\\", $c->bindings, $c->cacheFlag);\\n$stmt = $countQuery->prepare();\\n\\nif ($stmt && $stmt->execute()) {\\n    $fetchedData = $stmt->fetch(PDO::FETCH_ASSOC);\\n    $total = intval($fetchedData[\'total\']);\\n    $maxCnt = intval($fetchedData[\'max_cnt\']);\\n} else {\\n    $total = 0;\\n    $maxCnt = 0;\\n}\\n\\n$modx->setPlaceholder($totalPh, $total);\\n\\nforeach ($sort as $field => $dir) {\\n    $dir = (strtolower($dir) == \'asc\') ? \'asc\' : \'desc\';\\n    $c->sortby($field, $dir);\\n}\\n\\n$c->limit($limit, $offset);\\n\\n$tags = $modx->getIterator(\'TaggerTag\', $c);\\n\\n$out = array();\\n\\n\\/\\/ prep for &tpl_N\\n$keys = array_keys($scriptProperties);\\n$nthTpls = array();\\nforeach($keys as $key) {\\n    $keyBits = $tagger->explodeAndClean($key, \'_\');\\n    if (isset($keyBits[0]) && $keyBits[0] === \'tpl\') {\\n        if ($i = (int) $keyBits[1]) $nthTpls[$i] = $scriptProperties[$key];\\n    }\\n}\\nksort($nthTpls);\\n\\n$idx = 1;\\n$currentTags = $tagger->getCurrentTags();\\n$currentTagsLink = array();\\n\\nif ($linkCurrentTags == 1) {\\n    foreach($currentTags as $currentTag) {\\n        $currentTagsLink[$currentTag[\'alias\']] = array_keys($currentTag[\'tags\']);\\n    }\\n}\\n\\nforeach ($tags as $tag) {\\n    \\/** @var TaggerTag $tag *\\/\\n    $phs = $tag->toArray();\\n\\n    $group = $tag->Group;\\n\\n    if (($linkOneTagPerGroup === 1) && $currentTagsLink[$group->alias]) {\\n        $linkData = $currentTagsLink;\\n        if (!in_array($tag->alias, $linkData[$group->alias])) {\\n            $linkData[$group->alias] = array($tag->alias);\\n        } else {\\n            $linkData[$group->alias] = array();\\n        }\\n    } else {\\n        $linkData = array_merge_recursive($currentTagsLink, array(\\n            $group->alias => array($tag->alias)\\n        ));\\n    }\\n\\n    $linkData = array_filter(array_map(function($data) {\\n        return array_filter($data, function($value) use ($data) {\\n            return !(array_count_values($data)[$value] > 1);\\n        });\\n    }, $linkData));\\n\\n    if ($friendlyURL == 1) {\\n        $linkPath = array_reduce(array_keys($linkData), function($carry, $item) use ($linkData) {\\n            return $carry . $item . \'\\/\' . implode(\'\\/\', array_unique($linkData[$item])) . \'\\/\';\\n        }, \'\');\\n\\n        $uri = rtrim($modx->makeUrl($target, \'\', \'\', $linkTagScheme), \'\\/\') . \'\\/\' . $linkPath;\\n    } else {\\n        $linkPath = http_build_query(\\n            array_map(function($values) {\\n                return is_array($values) ? implode(\',\', array_unique($values)) : $values;\\n            }, $linkData)\\n        );\\n\\n        $uri = $modx->makeUrl($target, \'\', $linkPath, $linkTagScheme);\\n    }\\n\\n    $phs[\'uri\'] = $uri;\\n    $phs[\'idx\'] = $idx;\\n    $phs[\'target\'] = $target;\\n    $phs[\'max_cnt\'] = $maxCnt;\\n\\n    if (isset($currentTags[$group->alias][\'tags\'][$tag->alias])) {\\n        $phs[\'active\'] = 1;\\n    } else {\\n        $phs[\'active\'] = 0;\\n    }\\n\\n    if ($weight > 0) {\\n        $phs[\'weight\'] = intval(ceil($phs[\'cnt\'] \\/ ($maxCnt \\/ $weight)));\\n    }\\n\\n    if ($translate == 1) {\\n        $groupNameTranslated = $modx->lexicon(\'tagger.custom.\' . $phs[\'group_alias\']);\\n        $groupDescriptionTranslated = $modx->lexicon(\'tagger.custom.\' . $phs[\'group_alias\'] . \'_desc\');\\n\\n        $phs[\'group_name_translated\'] = ($groupNameTranslated == \'tagger.custom.\' . $phs[\'group_alias\']) ? $phs[\'group_name\'] : $groupNameTranslated;\\n        $phs[\'group_description_translated\'] = ($groupDescriptionTranslated == \'tagger.custom.\' . $phs[\'group_alias\'] . \'_desc\') ? $phs[\'group_description\'] : $groupDescriptionTranslated;\\n    }\\n\\n    $rowTpl = $defaultRowTpl;\\n    $phs[\'sp\'] = $scriptProperties;\\n\\n    if ($rowTpl == \'\') {\\n        $out[] = \'<pre>\' . print_r($phs, true) . \'<\\/pre>\';\\n    } else {\\n        if (isset($nthTpls[$idx])) {\\n            $rowTpl = $nthTpls[$idx];\\n        } else {\\n            foreach ($nthTpls as $int => $tpl) {\\n                if ( ($idx % $int) === 0 ) $rowTpl = $tpl;\\n            }\\n        }\\n\\n        $out[] = $tagger->getChunk($rowTpl, $phs);\\n    }\\n\\n    $idx++;\\n}\\n\\n$out = implode($separator, $out);\\n\\nif ($outTpl != \'\') {\\n    if (!empty($out) || $wrapIfEmpty) {\\n        $noActiveTags = (int)(count($currentTags) === 0);\\n        $out = $tagger->getChunk($outTpl, array(\'tags\' => $out, \'sp\' => $scriptProperties, \'noActiveTags\' => $noActiveTags));\\n    }\\n}\\n\\nif (!empty($toPlaceholder)) {\\n    $modx->setPlaceholder($toPlaceholder, $out);\\n    return \'\';\\n}\\n\\nreturn $out;","locked":0,"properties":"a:15:{s:9:\\"resources\\";a:7:{s:4:\\"name\\";s:9:\\"resources\\";s:4:\\"desc\\";s:29:\\"tagger.gettags.resources_desc\\";s:4:\\"type\\";s:9:\\"textfield\\";s:7:\\"options\\";s:0:\\"\\";s:5:\\"value\\";s:0:\\"\\";s:7:\\"lexicon\\";s:17:\\"tagger:properties\\";s:4:\\"area\\";s:0:\\"\\";}s:6:\\"groups\\";a:7:{s:4:\\"name\\";s:6:\\"groups\\";s:4:\\"desc\\";s:26:\\"tagger.gettags.groups_desc\\";s:4:\\"type\\";s:9:\\"textfield\\";s:7:\\"options\\";s:0:\\"\\";s:5:\\"value\\";s:0:\\"\\";s:7:\\"lexicon\\";s:17:\\"tagger:properties\\";s:4:\\"area\\";s:0:\\"\\";}s:6:\\"rowTpl\\";a:7:{s:4:\\"name\\";s:6:\\"rowTpl\\";s:4:\\"desc\\";s:26:\\"tagger.gettags.rowTpl_desc\\";s:4:\\"type\\";s:9:\\"textfield\\";s:7:\\"options\\";s:0:\\"\\";s:5:\\"value\\";s:0:\\"\\";s:7:\\"lexicon\\";s:17:\\"tagger:properties\\";s:4:\\"area\\";s:0:\\"\\";}s:6:\\"outTpl\\";a:7:{s:4:\\"name\\";s:6:\\"outTpl\\";s:4:\\"desc\\";s:26:\\"tagger.gettags.outTpl_desc\\";s:4:\\"type\\";s:9:\\"textfield\\";s:7:\\"options\\";s:0:\\"\\";s:5:\\"value\\";s:0:\\"\\";s:7:\\"lexicon\\";s:17:\\"tagger:properties\\";s:4:\\"area\\";s:0:\\"\\";}s:9:\\"separator\\";a:7:{s:4:\\"name\\";s:9:\\"separator\\";s:4:\\"desc\\";s:29:\\"tagger.gettags.separator_desc\\";s:4:\\"type\\";s:9:\\"textfield\\";s:7:\\"options\\";s:0:\\"\\";s:5:\\"value\\";s:0:\\"\\";s:7:\\"lexicon\\";s:17:\\"tagger:properties\\";s:4:\\"area\\";s:0:\\"\\";}s:6:\\"target\\";a:7:{s:4:\\"name\\";s:6:\\"target\\";s:4:\\"desc\\";s:26:\\"tagger.gettags.target_desc\\";s:4:\\"type\\";s:9:\\"textfield\\";s:7:\\"options\\";s:0:\\"\\";s:5:\\"value\\";s:0:\\"\\";s:7:\\"lexicon\\";s:17:\\"tagger:properties\\";s:4:\\"area\\";s:0:\\"\\";}s:10:\\"showUnused\\";a:7:{s:4:\\"name\\";s:10:\\"showUnused\\";s:4:\\"desc\\";s:30:\\"tagger.gettags.showUnused_desc\\";s:4:\\"type\\";s:11:\\"numberfield\\";s:7:\\"options\\";s:0:\\"\\";s:5:\\"value\\";s:1:\\"0\\";s:7:\\"lexicon\\";s:17:\\"tagger:properties\\";s:4:\\"area\\";s:0:\\"\\";}s:15:\\"showUnpublished\\";a:7:{s:4:\\"name\\";s:15:\\"showUnpublished\\";s:4:\\"desc\\";s:35:\\"tagger.gettags.showUnpublished_desc\\";s:4:\\"type\\";s:11:\\"numberfield\\";s:7:\\"options\\";s:0:\\"\\";s:5:\\"value\\";s:1:\\"0\\";s:7:\\"lexicon\\";s:17:\\"tagger:properties\\";s:4:\\"area\\";s:0:\\"\\";}s:11:\\"showDeleted\\";a:7:{s:4:\\"name\\";s:11:\\"showDeleted\\";s:4:\\"desc\\";s:31:\\"tagger.gettags.showDeleted_desc\\";s:4:\\"type\\";s:11:\\"numberfield\\";s:7:\\"options\\";s:0:\\"\\";s:5:\\"value\\";s:1:\\"0\\";s:7:\\"lexicon\\";s:17:\\"tagger:properties\\";s:4:\\"area\\";s:0:\\"\\";}s:8:\\"contexts\\";a:7:{s:4:\\"name\\";s:8:\\"contexts\\";s:4:\\"desc\\";s:28:\\"tagger.gettags.contexts_desc\\";s:4:\\"type\\";s:9:\\"textfield\\";s:7:\\"options\\";s:0:\\"\\";s:5:\\"value\\";s:0:\\"\\";s:7:\\"lexicon\\";s:17:\\"tagger:properties\\";s:4:\\"area\\";s:0:\\"\\";}s:13:\\"toPlaceholder\\";a:7:{s:4:\\"name\\";s:13:\\"toPlaceholder\\";s:4:\\"desc\\";s:33:\\"tagger.gettags.toPlaceholder_desc\\";s:4:\\"type\\";s:9:\\"textfield\\";s:7:\\"options\\";s:0:\\"\\";s:5:\\"value\\";s:0:\\"\\";s:7:\\"lexicon\\";s:17:\\"tagger:properties\\";s:4:\\"area\\";s:0:\\"\\";}s:5:\\"limit\\";a:7:{s:4:\\"name\\";s:5:\\"limit\\";s:4:\\"desc\\";s:25:\\"tagger.gettags.limit_desc\\";s:4:\\"type\\";s:11:\\"numberfield\\";s:7:\\"options\\";s:0:\\"\\";s:5:\\"value\\";s:1:\\"0\\";s:7:\\"lexicon\\";s:17:\\"tagger:properties\\";s:4:\\"area\\";s:0:\\"\\";}s:6:\\"offset\\";a:7:{s:4:\\"name\\";s:6:\\"offset\\";s:4:\\"desc\\";s:26:\\"tagger.gettags.offset_desc\\";s:4:\\"type\\";s:11:\\"numberfield\\";s:7:\\"options\\";s:0:\\"\\";s:5:\\"value\\";s:1:\\"0\\";s:7:\\"lexicon\\";s:17:\\"tagger:properties\\";s:4:\\"area\\";s:0:\\"\\";}s:7:\\"totalPh\\";a:7:{s:4:\\"name\\";s:7:\\"totalPh\\";s:4:\\"desc\\";s:27:\\"tagger.gettags.totalPh_desc\\";s:4:\\"type\\";s:9:\\"textfield\\";s:7:\\"options\\";s:0:\\"\\";s:5:\\"value\\";s:10:\\"tags_total\\";s:7:\\"lexicon\\";s:17:\\"tagger:properties\\";s:4:\\"area\\";s:0:\\"\\";}s:4:\\"sort\\";a:7:{s:4:\\"name\\";s:4:\\"sort\\";s:4:\\"desc\\";s:24:\\"tagger.gettags.sort_desc\\";s:4:\\"type\\";s:9:\\"textfield\\";s:7:\\"options\\";s:0:\\"\\";s:5:\\"value\\";s:14:\\"{\\"tag\\": \\"asc\\"}\\";s:7:\\"lexicon\\";s:17:\\"tagger:properties\\";s:4:\\"area\\";s:0:\\"\\";}}","moduleguid":"","static":0,"static_file":"","content":"\\/**\\n * TaggerGetTags\\n *\\n * DESCRIPTION\\n *\\n * This Snippet allows you to list tags for resource(s), group(s) and all tags\\n *\\n * PROPERTIES:\\n *\\n * &resources           string      optional    Comma separated list of resources for which will be listed Tags\\n * &parents             string      optional    Comma separated list of parents for which will be listed Tags\\n * &groups              string      optional    Comma separated list of Tagger Groups for which will be listed Tags\\n * &rowTpl              string      optional    Name of a chunk that will be used for each Tag. If no chunk is given, array with available placeholders will be rendered\\n * &outTpl              string      optional    Name of a chunk that will be used for wrapping all tags. If no chunk is given, tags will be rendered without a wrapper\\n * &separator           string      optional    String separator, that will be used for separating Tags\\n * &limit               int         optional    Limit number of returned tag Tags\\n * &offset              int         optional    Offset the output by this number of Tags\\n * &totalPh             string      optional    Placeholder to output the total number of Tags regardless of &limit and &offset\\n * &target              int         optional    An ID of a resource that will be used for generating URI for a Tag. If no ID is given, current Resource ID will be used\\n * &showUnused          int         optional    If 1 is set, Tags that are not assigned to any Resource will be included to the output as well\\n * &showUnpublished     int         optional    If 1 is set, Tags that are assigned only to unpublished Resources will be included to the output as well\\n * &showDeleted         int         optional    If 1 is set, Tags that are assigned only to deleted Resources will be included to the output as well\\n * &linkCurrentTags     int         optional    If 1 is set, Current Tags will be included in generated URL, default behavior is to generate links to a single tag\\n * &linkOneTagPerGroup  int         optional    If 1 is set, Only one tag will be placed to a group (in the URI tags from same group will swap places); Only available for linkCurrentTags=1; Default: 0\\n * &contexts            string      optional    If set, will display only tags for resources in given contexts. Contexts can be separated by a comma\\n * &toPlaceholder       string      optional    If set, output will return in placeholder with given name\\n * &sort                string      optional    Sort options in JSON. Example {\\"tag\\": \\"ASC\\"} or multiple sort options {\\"group_id\\": \\"ASC\\", \\"tag\\": \\"ASC\\"}\\n * &friendlyURL         int         optional    If set, will be used instead of friendly_urls system setting to generate URL\\n * &linkTagScheme       int|string  optional    Strategy to generate URLs, available values: -1, 0, 1, full, abs, http, https; Default: link_tag_scheme system setting\\n *\\n * USAGE:\\n *\\n * [[!TaggerGetTags? &showUnused=`1`]]\\n *\\n *\\n * @package tagger\\n *\\/\\n\\n\\/** @var Tagger $tagger *\\/\\n$tagger = $modx->getService(\'tagger\',\'Tagger\',$modx->getOption(\'tagger.core_path\',null,$modx->getOption(\'core_path\').\'components\\/tagger\\/\').\'model\\/tagger\\/\',$scriptProperties);\\nif (!($tagger instanceof Tagger)) return \'\';\\n\\n$resources = $modx->getOption(\'resources\', $scriptProperties, \'\');\\n$parents = $modx->getOption(\'parents\', $scriptProperties, \'\');\\n$groups = $modx->getOption(\'groups\', $scriptProperties, \'\');\\n$target = (int) $modx->getOption(\'target\', $scriptProperties, $modx->resource->id, true);\\n$showUnused = (int) $modx->getOption(\'showUnused\', $scriptProperties, \'0\');\\n$showUnpublished = (int) $modx->getOption(\'showUnpublished\', $scriptProperties, \'0\');\\n$showDeleted = (int) $modx->getOption(\'showDeleted\', $scriptProperties, \'0\');\\n$linkCurrentTags = (int) $modx->getOption(\'linkCurrentTags\', $scriptProperties, \'0\');\\n$linkOneTagPerGroup = (int) $modx->getOption(\'linkOneTagPerGroup\', $scriptProperties, \'0\');\\n$contexts = $modx->getOption(\'contexts\', $scriptProperties, \'\');\\n$translate = (int) $modx->getOption(\'translate\', $scriptProperties, \'0\');\\n\\n$defaultRowTpl = $modx->getOption(\'rowTpl\', $scriptProperties, \'\');\\n$outTpl = $modx->getOption(\'outTpl\', $scriptProperties, \'\');\\n$wrapIfEmpty = $modx->getOption(\'wrapIfEmpty\', $scriptProperties, 1);\\n$separator = $modx->getOption(\'separator\', $scriptProperties, \'\');\\n$limit = intval($modx->getOption(\'limit\', $scriptProperties, 0));\\n$offset = intval($modx->getOption(\'offset\', $scriptProperties, 0));\\n$totalPh = $modx->getOption(\'totalPh\', $scriptProperties, \'tags_total\');\\n\\n$weight = (int) $modx->getOption(\'weight\', $scriptProperties, \'0\');\\n\\n$friendlyURL = (int) $modx->getOption(\'friendlyURL\', $scriptProperties, $modx->getOption(\'friendly_urls\', null, 0));\\n$linkTagScheme = $modx->getOption(\'linkTagScheme\', $scriptProperties, $modx->getOption(\'link_tag_scheme\', null, -1));\\n\\n$sort = $modx->getOption(\'sort\', $scriptProperties, \'{}\');\\n$sort = $modx->fromJSON($sort);\\nif ($sort === null || $sort == \'\' || count($sort) == 0) {\\n    $sort = array(\\n        \'tag\' => \'ASC\'\\n    );\\n}\\n\\n$resources = $tagger->explodeAndClean($resources);\\n$parents = $tagger->explodeAndClean($parents);\\n$groups = $tagger->explodeAndClean($groups);\\n$contexts = $tagger->explodeAndClean($contexts);\\n$toPlaceholder = $modx->getOption(\'toPlaceholder\', $scriptProperties, \'\');\\n\\n$c = $modx->newQuery(\'TaggerTag\');\\n\\n$c->leftJoin(\'TaggerTagResource\', \'Resources\');\\n$c->leftJoin(\'TaggerGroup\', \'Group\');\\n$c->leftJoin(\'modResource\', \'Resource\', array(\'Resources.resource = Resource.id\'));\\n\\nif (!empty($parents)) {\\n    $c->where(array(\\n        \'Resource.parent:IN\' => $parents,\\n    ));\\n}\\n\\nif (!empty($contexts)) {\\n    $c->where(array(\\n        \'Resource.context_key:IN\' => $contexts,\\n    ));\\n}\\n\\nif ($showUnpublished == 0) {\\n    $c->where(array(\\n        \'Resource.published\' => 1,\\n        \'OR:Resource.published:IN\' => null,\\n    ));\\n}\\n\\nif ($showDeleted == 0) {\\n    $c->where(array(\\n        \'Resource.deleted\' => 0,\\n        \'OR:Resource.deleted:IS\' => null,\\n    ));\\n}\\n\\nif ($showUnused == 0) {\\n    $c->having(array(\\n        \'cnt > 0\',\\n    ));\\n}\\n\\nif (!empty($resources)) {\\n    $c->where(array(\\n        \'Resources.resource:IN\' => $resources\\n    ));\\n}\\n\\nif ($groups) {\\n    $c->where(array(\\n        \'Group.id:IN\' => $groups,\\n        \'OR:Group.name:IN\' => $groups,\\n        \'OR:Group.alias:IN\' => $groups,\\n    ));\\n}\\n$c->select($modx->getSelectColumns(\'TaggerTag\', \'TaggerTag\'));\\n$c->select($modx->getSelectColumns(\'TaggerGroup\', \'Group\', \'group_\'));\\n$c->select(array(\'cnt\' => \'COUNT(Resources.tag)\'));\\n$c->groupby($modx->getSelectColumns(\'TaggerTag\', \'TaggerTag\') . \',\' . $modx->getSelectColumns(\'TaggerGroup\', \'Group\'));\\n\\n$c->prepare();\\n\\n$countQuery = new xPDOCriteria($modx, \\"SELECT COUNT(*) as total, MAX(cnt) as max_cnt FROM ({$c->toSQL(false)}) cq\\", $c->bindings, $c->cacheFlag);\\n$stmt = $countQuery->prepare();\\n\\nif ($stmt && $stmt->execute()) {\\n    $fetchedData = $stmt->fetch(PDO::FETCH_ASSOC);\\n    $total = intval($fetchedData[\'total\']);\\n    $maxCnt = intval($fetchedData[\'max_cnt\']);\\n} else {\\n    $total = 0;\\n    $maxCnt = 0;\\n}\\n\\n$modx->setPlaceholder($totalPh, $total);\\n\\nforeach ($sort as $field => $dir) {\\n    $dir = (strtolower($dir) == \'asc\') ? \'asc\' : \'desc\';\\n    $c->sortby($field, $dir);\\n}\\n\\n$c->limit($limit, $offset);\\n\\n$tags = $modx->getIterator(\'TaggerTag\', $c);\\n\\n$out = array();\\n\\n\\/\\/ prep for &tpl_N\\n$keys = array_keys($scriptProperties);\\n$nthTpls = array();\\nforeach($keys as $key) {\\n    $keyBits = $tagger->explodeAndClean($key, \'_\');\\n    if (isset($keyBits[0]) && $keyBits[0] === \'tpl\') {\\n        if ($i = (int) $keyBits[1]) $nthTpls[$i] = $scriptProperties[$key];\\n    }\\n}\\nksort($nthTpls);\\n\\n$idx = 1;\\n$currentTags = $tagger->getCurrentTags();\\n$currentTagsLink = array();\\n\\nif ($linkCurrentTags == 1) {\\n    foreach($currentTags as $currentTag) {\\n        $currentTagsLink[$currentTag[\'alias\']] = array_keys($currentTag[\'tags\']);\\n    }\\n}\\n\\nforeach ($tags as $tag) {\\n    \\/** @var TaggerTag $tag *\\/\\n    $phs = $tag->toArray();\\n\\n    $group = $tag->Group;\\n\\n    if (($linkOneTagPerGroup === 1) && $currentTagsLink[$group->alias]) {\\n        $linkData = $currentTagsLink;\\n        if (!in_array($tag->alias, $linkData[$group->alias])) {\\n            $linkData[$group->alias] = array($tag->alias);\\n        } else {\\n            $linkData[$group->alias] = array();\\n        }\\n    } else {\\n        $linkData = array_merge_recursive($currentTagsLink, array(\\n            $group->alias => array($tag->alias)\\n        ));\\n    }\\n\\n    $linkData = array_filter(array_map(function($data) {\\n        return array_filter($data, function($value) use ($data) {\\n            return !(array_count_values($data)[$value] > 1);\\n        });\\n    }, $linkData));\\n\\n    if ($friendlyURL == 1) {\\n        $linkPath = array_reduce(array_keys($linkData), function($carry, $item) use ($linkData) {\\n            return $carry . $item . \'\\/\' . implode(\'\\/\', array_unique($linkData[$item])) . \'\\/\';\\n        }, \'\');\\n\\n        $uri = rtrim($modx->makeUrl($target, \'\', \'\', $linkTagScheme), \'\\/\') . \'\\/\' . $linkPath;\\n    } else {\\n        $linkPath = http_build_query(\\n            array_map(function($values) {\\n                return is_array($values) ? implode(\',\', array_unique($values)) : $values;\\n            }, $linkData)\\n        );\\n\\n        $uri = $modx->makeUrl($target, \'\', $linkPath, $linkTagScheme);\\n    }\\n\\n    $phs[\'uri\'] = $uri;\\n    $phs[\'idx\'] = $idx;\\n    $phs[\'target\'] = $target;\\n    $phs[\'max_cnt\'] = $maxCnt;\\n\\n    if (isset($currentTags[$group->alias][\'tags\'][$tag->alias])) {\\n        $phs[\'active\'] = 1;\\n    } else {\\n        $phs[\'active\'] = 0;\\n    }\\n\\n    if ($weight > 0) {\\n        $phs[\'weight\'] = intval(ceil($phs[\'cnt\'] \\/ ($maxCnt \\/ $weight)));\\n    }\\n\\n    if ($translate == 1) {\\n        $groupNameTranslated = $modx->lexicon(\'tagger.custom.\' . $phs[\'group_alias\']);\\n        $groupDescriptionTranslated = $modx->lexicon(\'tagger.custom.\' . $phs[\'group_alias\'] . \'_desc\');\\n\\n        $phs[\'group_name_translated\'] = ($groupNameTranslated == \'tagger.custom.\' . $phs[\'group_alias\']) ? $phs[\'group_name\'] : $groupNameTranslated;\\n        $phs[\'group_description_translated\'] = ($groupDescriptionTranslated == \'tagger.custom.\' . $phs[\'group_alias\'] . \'_desc\') ? $phs[\'group_description\'] : $groupDescriptionTranslated;\\n    }\\n\\n    $rowTpl = $defaultRowTpl;\\n    $phs[\'sp\'] = $scriptProperties;\\n\\n    if ($rowTpl == \'\') {\\n        $out[] = \'<pre>\' . print_r($phs, true) . \'<\\/pre>\';\\n    } else {\\n        if (isset($nthTpls[$idx])) {\\n            $rowTpl = $nthTpls[$idx];\\n        } else {\\n            foreach ($nthTpls as $int => $tpl) {\\n                if ( ($idx % $int) === 0 ) $rowTpl = $tpl;\\n            }\\n        }\\n\\n        $out[] = $tagger->getChunk($rowTpl, $phs);\\n    }\\n\\n    $idx++;\\n}\\n\\n$out = implode($separator, $out);\\n\\nif ($outTpl != \'\') {\\n    if (!empty($out) || $wrapIfEmpty) {\\n        $noActiveTags = (int)(count($currentTags) === 0);\\n        $out = $tagger->getChunk($outTpl, array(\'tags\' => $out, \'sp\' => $scriptProperties, \'noActiveTags\' => $noActiveTags));\\n    }\\n}\\n\\nif (!empty($toPlaceholder)) {\\n    $modx->setPlaceholder($toPlaceholder, $out);\\n    return \'\';\\n}\\n\\nreturn $out;"}',
        'guid' => '3676564ce21b4eb50207faaac9643177',
        'native_key' => NULL,
        'signature' => 'b471e7125eb34e73462ef8d9f6b6bfe3',
      ),
      '7a38060c528217238a6b3a79c57d277f' => 
      array (
        'preserve_keys' => false,
        'update_object' => true,
        'unique_key' => 'name',
        'class' => 'modSnippet',
        'object' => '{"id":null,"source":0,"property_preprocess":0,"name":"TaggerGetResourcesWhere","description":"","editor_type":0,"category":0,"cache_type":0,"snippet":"\\/**\\n * TaggerGetResourcesWhere\\n *\\n * DESCRIPTION\\n *\\n * This snippet generate SQL Query that can be used in WHERE condition in getResources snippet\\n *\\n * PROPERTIES:\\n *\\n * &tags            string  optional    Comma separated list of Tags for which will be generated a Resource query. By default Tags from GET param will be loaded\\n * &groups          string  optional    Comma separated list of Tagger Groups. Only from those groups will Tags be allowed\\n * &where           string  optional    Original getResources where property. If you used where property in your current getResources call, move it here\\n * &likeComparison  int     optional    If set to 1, tags will compare using LIKE\\n * &tagField        string  optional    Field that will be used to compare with given tags. Default: alias\\n * &matchAll        int     optional    If set to 1, resource must have all specified tags. Default: 0\\n * &field           string  optional    modResource field that will be used to compare with assigned resource ID\\n *\\n * USAGE:\\n *\\n * [[!getResources? &where=`[[!TaggerGetResourcesWhere? &tags=`Books,Vehicles` &where=`{\\"isfolder\\": 0}`]]`]]\\n *\\n *\\/\\n\\n$tagger = $modx->getService(\'tagger\',\'Tagger\',$modx->getOption(\'tagger.core_path\',null,$modx->getOption(\'core_path\').\'components\\/tagger\\/\').\'model\\/tagger\\/\',$scriptProperties);\\nif (!($tagger instanceof Tagger)) return \'\';\\n\\n$tags = $modx->getOption(\'tags\', $scriptProperties, \'\');\\n$where = $modx->getOption(\'where\', $scriptProperties, \'\');\\n$tagField = $modx->getOption(\'tagField\', $scriptProperties, \'alias\');\\n$likeComparison = (int) $modx->getOption(\'likeComparison\', $scriptProperties, 0);\\n$matchAll = (int) $modx->getOption(\'matchAll\', $scriptProperties, 0);\\n$field = $modx->getOption(\'field\', $scriptProperties, \'id\');\\n$where = $modx->fromJSON($where);\\nif ($where == false) {\\n    $where = array();\\n}\\n\\n$tagsCount = 0;\\n\\nif ($tags == \'\') {\\n    $gc = $modx->newQuery(\'TaggerGroup\');\\n    $gc->select($modx->getSelectColumns(\'TaggerGroup\', \'\', \'\', array(\'alias\')));\\n\\n    $groups = $modx->getOption(\'groups\', $scriptProperties, \'\');\\n    $groups = $tagger->explodeAndClean($groups);\\n    if (!empty($groups)) {\\n        $gc->where(array(\\n            \'name:IN\' => $groups,\\n            \'OR:alias:IN\' => $groups,\\n            \'OR:id:IN\' => $groups,\\n        ));\\n    }\\n\\n    $gc->prepare();\\n    $gc->stmt->execute();\\n    $groups = $gc->stmt->fetchAll(PDO::FETCH_COLUMN, 0);\\n\\n    $conditions = array();\\n    foreach ($groups as $group) {\\n        if (isset($_GET[$group])) {\\n            $groupTags = $tagger->explodeAndClean($_GET[$group]);\\n            if (!empty($groupTags)) {\\n                $like = array(\'AND:alias:IN\' => $groupTags);\\n\\n                if ($likeComparison == 1) {\\n                    foreach ($groupTags as $tag) {\\n                        $like[] = array(\'OR:alias:LIKE\' => \'%\' . $tag . \'%\');\\n                    }\\n                }\\n\\n                $conditions[] = array(\\n                    \'OR:Group.alias:=\' => $group,\\n                    $like\\n                );\\n                $tagsCount += count($groupTags);\\n            }\\n        }\\n    }\\n\\n    if (count($conditions) == 0) {\\n        return $modx->toJSON($where);\\n    }\\n\\n    $c = $modx->newQuery(\'TaggerTag\');\\n    $c->leftJoin(\'TaggerGroup\', \'Group\');\\n\\n    $c->where($conditions);\\n} else {\\n    $tags = $tagger->explodeAndClean($tags);\\n\\n    if (empty($tags)) {\\n        return $modx->toJSON($where);\\n    }\\n\\n    $tagsCount = count($tags);\\n\\n    $groups = $modx->getOption(\'groups\', $scriptProperties, \'\');\\n\\n    $groups = $tagger->explodeAndClean($groups);\\n\\n    $c = $modx->newQuery(\'TaggerTag\');\\n    $c->select($modx->getSelectColumns(\'TaggerTag\', \'TaggerTag\', \'\', array(\'id\')));\\n\\n    $compare = array(\\n        $tagField . \':IN\' => $tags\\n    );\\n\\n    if ($likeComparison == 1) {\\n        foreach ($tags as $tag) {\\n            $compare[] = array(\'OR:\' . $tagField . \':LIKE\' => \'%\' . $tag . \'%\');\\n        }\\n    }\\n\\n    $c->where($compare);\\n\\n    if (!empty($groups)) {\\n        $c->leftJoin(\'TaggerGroup\', \'Group\');\\n        $c->where(array(\\n            \'Group.id:IN\' => $groups,\\n            \'OR:Group.name:IN\' => $groups,\\n            \'OR:Group.alias:IN\' => $groups,\\n        ));\\n    }\\n}\\n\\n$c->prepare();\\n$c->stmt->execute();\\n$tagIDs = $c->stmt->fetchAll(PDO::FETCH_COLUMN, 0);\\n\\nif (count($tagIDs) == 0) {\\n    $tagIDs[] = 0;\\n}\\n\\nif ($matchAll == 0) {\\n    $where[] = \\"EXISTS (SELECT 1 FROM {$modx->getTableName(\'TaggerTagResource\')} r WHERE r.tag IN (\\" . implode(\',\', $tagIDs) . \\") AND r.resource = modResource.\\" . $field . \\")\\";\\n} else {\\n    $where[] = \\"EXISTS (SELECT 1 as found FROM {$modx->getTableName(\'TaggerTagResource\')} r WHERE r.tag IN (\\" . implode(\',\', $tagIDs) . \\") AND r.resource = modResource.\\" . $field . \\" GROUP BY found HAVING count(found) = \\" . $tagsCount . \\")\\";\\n}\\n\\nreturn $modx->toJSON($where);","locked":0,"properties":"a:6:{s:4:\\"tags\\";a:7:{s:4:\\"name\\";s:4:\\"tags\\";s:4:\\"desc\\";s:34:\\"tagger.getresourceswhere.tags_desc\\";s:4:\\"type\\";s:9:\\"textfield\\";s:7:\\"options\\";s:0:\\"\\";s:5:\\"value\\";s:0:\\"\\";s:7:\\"lexicon\\";s:17:\\"tagger:properties\\";s:4:\\"area\\";s:0:\\"\\";}s:6:\\"groups\\";a:7:{s:4:\\"name\\";s:6:\\"groups\\";s:4:\\"desc\\";s:36:\\"tagger.getresourceswhere.groups_desc\\";s:4:\\"type\\";s:9:\\"textfield\\";s:7:\\"options\\";s:0:\\"\\";s:5:\\"value\\";s:0:\\"\\";s:7:\\"lexicon\\";s:17:\\"tagger:properties\\";s:4:\\"area\\";s:0:\\"\\";}s:5:\\"where\\";a:7:{s:4:\\"name\\";s:5:\\"where\\";s:4:\\"desc\\";s:35:\\"tagger.getresourceswhere.where_desc\\";s:4:\\"type\\";s:9:\\"textfield\\";s:7:\\"options\\";s:0:\\"\\";s:5:\\"value\\";s:0:\\"\\";s:7:\\"lexicon\\";s:17:\\"tagger:properties\\";s:4:\\"area\\";s:0:\\"\\";}s:14:\\"likeComparison\\";a:7:{s:4:\\"name\\";s:14:\\"likeComparison\\";s:4:\\"desc\\";s:44:\\"tagger.getresourceswhere.likeComparison_desc\\";s:4:\\"type\\";s:11:\\"numberfield\\";s:7:\\"options\\";s:0:\\"\\";s:5:\\"value\\";s:1:\\"0\\";s:7:\\"lexicon\\";s:17:\\"tagger:properties\\";s:4:\\"area\\";s:0:\\"\\";}s:8:\\"tagField\\";a:7:{s:4:\\"name\\";s:8:\\"tagField\\";s:4:\\"desc\\";s:38:\\"tagger.getresourceswhere.tagField_desc\\";s:4:\\"type\\";s:9:\\"textfield\\";s:7:\\"options\\";s:0:\\"\\";s:5:\\"value\\";s:5:\\"alias\\";s:7:\\"lexicon\\";s:17:\\"tagger:properties\\";s:4:\\"area\\";s:0:\\"\\";}s:8:\\"matchAll\\";a:7:{s:4:\\"name\\";s:8:\\"matchAll\\";s:4:\\"desc\\";s:38:\\"tagger.getresourceswhere.matchAll_desc\\";s:4:\\"type\\";s:11:\\"numberfield\\";s:7:\\"options\\";s:0:\\"\\";s:5:\\"value\\";s:1:\\"0\\";s:7:\\"lexicon\\";s:17:\\"tagger:properties\\";s:4:\\"area\\";s:0:\\"\\";}}","moduleguid":"","static":0,"static_file":"","content":"\\/**\\n * TaggerGetResourcesWhere\\n *\\n * DESCRIPTION\\n *\\n * This snippet generate SQL Query that can be used in WHERE condition in getResources snippet\\n *\\n * PROPERTIES:\\n *\\n * &tags            string  optional    Comma separated list of Tags for which will be generated a Resource query. By default Tags from GET param will be loaded\\n * &groups          string  optional    Comma separated list of Tagger Groups. Only from those groups will Tags be allowed\\n * &where           string  optional    Original getResources where property. If you used where property in your current getResources call, move it here\\n * &likeComparison  int     optional    If set to 1, tags will compare using LIKE\\n * &tagField        string  optional    Field that will be used to compare with given tags. Default: alias\\n * &matchAll        int     optional    If set to 1, resource must have all specified tags. Default: 0\\n * &field           string  optional    modResource field that will be used to compare with assigned resource ID\\n *\\n * USAGE:\\n *\\n * [[!getResources? &where=`[[!TaggerGetResourcesWhere? &tags=`Books,Vehicles` &where=`{\\"isfolder\\": 0}`]]`]]\\n *\\n *\\/\\n\\n$tagger = $modx->getService(\'tagger\',\'Tagger\',$modx->getOption(\'tagger.core_path\',null,$modx->getOption(\'core_path\').\'components\\/tagger\\/\').\'model\\/tagger\\/\',$scriptProperties);\\nif (!($tagger instanceof Tagger)) return \'\';\\n\\n$tags = $modx->getOption(\'tags\', $scriptProperties, \'\');\\n$where = $modx->getOption(\'where\', $scriptProperties, \'\');\\n$tagField = $modx->getOption(\'tagField\', $scriptProperties, \'alias\');\\n$likeComparison = (int) $modx->getOption(\'likeComparison\', $scriptProperties, 0);\\n$matchAll = (int) $modx->getOption(\'matchAll\', $scriptProperties, 0);\\n$field = $modx->getOption(\'field\', $scriptProperties, \'id\');\\n$where = $modx->fromJSON($where);\\nif ($where == false) {\\n    $where = array();\\n}\\n\\n$tagsCount = 0;\\n\\nif ($tags == \'\') {\\n    $gc = $modx->newQuery(\'TaggerGroup\');\\n    $gc->select($modx->getSelectColumns(\'TaggerGroup\', \'\', \'\', array(\'alias\')));\\n\\n    $groups = $modx->getOption(\'groups\', $scriptProperties, \'\');\\n    $groups = $tagger->explodeAndClean($groups);\\n    if (!empty($groups)) {\\n        $gc->where(array(\\n            \'name:IN\' => $groups,\\n            \'OR:alias:IN\' => $groups,\\n            \'OR:id:IN\' => $groups,\\n        ));\\n    }\\n\\n    $gc->prepare();\\n    $gc->stmt->execute();\\n    $groups = $gc->stmt->fetchAll(PDO::FETCH_COLUMN, 0);\\n\\n    $conditions = array();\\n    foreach ($groups as $group) {\\n        if (isset($_GET[$group])) {\\n            $groupTags = $tagger->explodeAndClean($_GET[$group]);\\n            if (!empty($groupTags)) {\\n                $like = array(\'AND:alias:IN\' => $groupTags);\\n\\n                if ($likeComparison == 1) {\\n                    foreach ($groupTags as $tag) {\\n                        $like[] = array(\'OR:alias:LIKE\' => \'%\' . $tag . \'%\');\\n                    }\\n                }\\n\\n                $conditions[] = array(\\n                    \'OR:Group.alias:=\' => $group,\\n                    $like\\n                );\\n                $tagsCount += count($groupTags);\\n            }\\n        }\\n    }\\n\\n    if (count($conditions) == 0) {\\n        return $modx->toJSON($where);\\n    }\\n\\n    $c = $modx->newQuery(\'TaggerTag\');\\n    $c->leftJoin(\'TaggerGroup\', \'Group\');\\n\\n    $c->where($conditions);\\n} else {\\n    $tags = $tagger->explodeAndClean($tags);\\n\\n    if (empty($tags)) {\\n        return $modx->toJSON($where);\\n    }\\n\\n    $tagsCount = count($tags);\\n\\n    $groups = $modx->getOption(\'groups\', $scriptProperties, \'\');\\n\\n    $groups = $tagger->explodeAndClean($groups);\\n\\n    $c = $modx->newQuery(\'TaggerTag\');\\n    $c->select($modx->getSelectColumns(\'TaggerTag\', \'TaggerTag\', \'\', array(\'id\')));\\n\\n    $compare = array(\\n        $tagField . \':IN\' => $tags\\n    );\\n\\n    if ($likeComparison == 1) {\\n        foreach ($tags as $tag) {\\n            $compare[] = array(\'OR:\' . $tagField . \':LIKE\' => \'%\' . $tag . \'%\');\\n        }\\n    }\\n\\n    $c->where($compare);\\n\\n    if (!empty($groups)) {\\n        $c->leftJoin(\'TaggerGroup\', \'Group\');\\n        $c->where(array(\\n            \'Group.id:IN\' => $groups,\\n            \'OR:Group.name:IN\' => $groups,\\n            \'OR:Group.alias:IN\' => $groups,\\n        ));\\n    }\\n}\\n\\n$c->prepare();\\n$c->stmt->execute();\\n$tagIDs = $c->stmt->fetchAll(PDO::FETCH_COLUMN, 0);\\n\\nif (count($tagIDs) == 0) {\\n    $tagIDs[] = 0;\\n}\\n\\nif ($matchAll == 0) {\\n    $where[] = \\"EXISTS (SELECT 1 FROM {$modx->getTableName(\'TaggerTagResource\')} r WHERE r.tag IN (\\" . implode(\',\', $tagIDs) . \\") AND r.resource = modResource.\\" . $field . \\")\\";\\n} else {\\n    $where[] = \\"EXISTS (SELECT 1 as found FROM {$modx->getTableName(\'TaggerTagResource\')} r WHERE r.tag IN (\\" . implode(\',\', $tagIDs) . \\") AND r.resource = modResource.\\" . $field . \\" GROUP BY found HAVING count(found) = \\" . $tagsCount . \\")\\";\\n}\\n\\nreturn $modx->toJSON($where);"}',
        'guid' => 'e8784c7d4c3ca9a66c8e4730c5bb374a',
        'native_key' => NULL,
        'signature' => '407465ede47c6da25273b2f4c3ae349a',
      ),
      '355ba01d5498f491004e3197808dff1b' => 
      array (
        'preserve_keys' => false,
        'update_object' => true,
        'unique_key' => 'name',
        'class' => 'modSnippet',
        'object' => '{"id":null,"source":0,"property_preprocess":0,"name":"TaggerGetRelatedWhere","description":"","editor_type":0,"category":0,"cache_type":0,"snippet":"\\/**\\n * TaggerGetRelatedWhere\\n *\\n * DESCRIPTION\\n *\\n * This snippet generates a SQL Query that can be used in WHERE condition in getResources snippet\\n * to get related resources, which have the same tags \\n *\\n * PROPERTIES:\\n *\\n * &resources       string  optional    Comma separated list of resources for which will be listed Tags. Default: current resource\\n * &groups          string  optional    Comma separated list of Tagger Groups for which will be listed Tags\\n * &showUnused      int     optional    If 1 is set, Tags that are not assigned to any Resource will be included to the output as well\\n * &showUnpublished int     optional    If 1 is set, Tags that are assigned only to unpublished Resources will be included to the output as well\\n * &showDeleted     int     optional    If 1 is set, Tags that are assigned only to deleted Resources will be included to the output as well\\n * &contexts        string  optional    If set, will display only tags for resources in given contexts. Contexts can be separated by a comma\\n * \\n * TaggerGetResourcesWhere - PROPERTIES:\\n * \\n * &tags            string  optional    Comma separated list of Tags for which will be generated a Resource query. By default Tags from GET param will be loaded\\n * &groups          string  optional    Comma separated list of Tagger Groups. Only from those groups will Tags be allowed\\n * &where           string  optional    Original getResources where property. If you used where property in your current getResources call, move it here\\n * &likeComparison  int     optional    If set to 1, tags will compare using LIKE\\n * &tagField        string  optional    Field that will be used to compare with given tags. Default: alias\\n * &matchAll        int     optional    If set to 1, resource must have all specified tags. Default: 0 \\n *\\n * USAGE:\\n *\\n * [[!TaggerGetRelatedWhere? &groups=`1` ]]\\n *\\n *\\n * @package tagger\\n *\\/\\n\\n\\/** @var Tagger $tagger *\\/\\n$tagger = $modx->getService(\'tagger\', \'Tagger\', $modx->getOption(\'tagger.core_path\', null, $modx->getOption(\'core_path\') . \'components\\/tagger\\/\') . \'model\\/tagger\\/\', $scriptProperties);\\nif (!($tagger instanceof Tagger))\\n    return \'\';\\n\\n$resources = $modx->getOption(\'resources\', $scriptProperties, is_object($modx->resource) ? $modx->resource->get(\'id\') : \'\');\\n$groups = $modx->getOption(\'groups\', $scriptProperties, \'\');\\n$showUnused = (int)$modx->getOption(\'showUnused\', $scriptProperties, \'0\');\\n$showUnpublished = (int)$modx->getOption(\'showUnpublished\', $scriptProperties, \'0\');\\n$showDeleted = (int)$modx->getOption(\'showDeleted\', $scriptProperties, \'0\');\\n$contexts = $modx->getOption(\'contexts\', $scriptProperties, \'\');\\n\\n$totalPh = $modx->getOption(\'totalPh\', $scriptProperties, \'tags_total\');\\n\\n$resources = $tagger->explodeAndClean($resources);\\n$groups = $tagger->explodeAndClean($groups);\\n$contexts = $tagger->explodeAndClean($contexts);\\n\\n$c = $modx->newQuery(\'TaggerTag\');\\n\\n$c->leftJoin(\'TaggerTagResource\', \'Resources\');\\n$c->leftJoin(\'TaggerGroup\', \'Group\');\\n$c->leftJoin(\'modResource\', \'Resource\', array(\'Resources.resource = Resource.id\'));\\n\\n\\nif (!empty($contexts)) {\\n    $c->where(array(\'Resource.context_key:IN\' => $contexts, ));\\n}\\n\\nif ($showUnpublished == 0) {\\n    $c->where(array(\\n        \'Resource.published\' => 1,\\n        \'OR:Resource.published:IN\' => null,\\n        ));\\n}\\n\\nif ($showDeleted == 0) {\\n    $c->where(array(\\n        \'Resource.deleted\' => 0,\\n        \'OR:Resource.deleted:IS\' => null,\\n        ));\\n}\\n\\nif ($showUnused == 0) {\\n    $c->having(array(\'cnt > 0\', ));\\n}\\n\\nif ($resources) {\\n    $c->where(array(\'Resources.resource:IN\' => $resources));\\n}\\n\\nif ($groups) {\\n    $c->where(array(\\n        \'Group.id:IN\' => $groups,\\n        \'OR:Group.name:IN\' => $groups,\\n        \'OR:Group.alias:IN\' => $groups,\\n        ));\\n}\\n$c->select($modx->getSelectColumns(\'TaggerTag\', \'TaggerTag\'));\\n\\/\\/$c->select($modx->getSelectColumns(\'TaggerGroup\', \'Group\', \'group_\'));\\n$c->select(array(\'cnt\' => \'COUNT(Resources.tag)\'));\\n$c->groupby($modx->getSelectColumns(\'TaggerTag\', \'TaggerTag\') . \',\' . $modx->getSelectColumns(\'TaggerGroup\', \'Group\'));\\n\\n$c->prepare();\\n$countQuery = new xPDOCriteria($modx, \\"SELECT COUNT(*) FROM ({$c->toSQL(false)}) cq\\", $c->bindings, $c->cacheFlag);\\n$stmt = $countQuery->prepare();\\nif ($stmt && $stmt->execute()) {\\n    $total = intval($stmt->fetchColumn());\\n} else {\\n    $total = 0;\\n}\\n\\n$modx->setPlaceholder($totalPh, $total);\\n\\n$tags = array();\\n\\nif ($collection = $modx->getIterator(\'TaggerTag\', $c)) {\\n    foreach ($collection as $tag) {\\n        $tags[] = $tag->get(\'alias\');\\n    }\\n}\\n\\n$wherecondition = array(\'id:not IN\' => $resources);\\n\\n$scriptProperties[\'where\'] = $modx->toJson($wherecondition);\\n\\n$output = \'{\\"template\\":\\"99999999\\"}\';\\n\\nif (count($tags)) {\\n    $scriptProperties[\'tags\'] = implode(\',\', $tags);\\n    $output = $modx->runSnippet(\'TaggerGetResourcesWhere\', $scriptProperties);\\n}\\n\\nreturn $output;","locked":0,"properties":"a:0:{}","moduleguid":"","static":0,"static_file":"","content":"\\/**\\n * TaggerGetRelatedWhere\\n *\\n * DESCRIPTION\\n *\\n * This snippet generates a SQL Query that can be used in WHERE condition in getResources snippet\\n * to get related resources, which have the same tags \\n *\\n * PROPERTIES:\\n *\\n * &resources       string  optional    Comma separated list of resources for which will be listed Tags. Default: current resource\\n * &groups          string  optional    Comma separated list of Tagger Groups for which will be listed Tags\\n * &showUnused      int     optional    If 1 is set, Tags that are not assigned to any Resource will be included to the output as well\\n * &showUnpublished int     optional    If 1 is set, Tags that are assigned only to unpublished Resources will be included to the output as well\\n * &showDeleted     int     optional    If 1 is set, Tags that are assigned only to deleted Resources will be included to the output as well\\n * &contexts        string  optional    If set, will display only tags for resources in given contexts. Contexts can be separated by a comma\\n * \\n * TaggerGetResourcesWhere - PROPERTIES:\\n * \\n * &tags            string  optional    Comma separated list of Tags for which will be generated a Resource query. By default Tags from GET param will be loaded\\n * &groups          string  optional    Comma separated list of Tagger Groups. Only from those groups will Tags be allowed\\n * &where           string  optional    Original getResources where property. If you used where property in your current getResources call, move it here\\n * &likeComparison  int     optional    If set to 1, tags will compare using LIKE\\n * &tagField        string  optional    Field that will be used to compare with given tags. Default: alias\\n * &matchAll        int     optional    If set to 1, resource must have all specified tags. Default: 0 \\n *\\n * USAGE:\\n *\\n * [[!TaggerGetRelatedWhere? &groups=`1` ]]\\n *\\n *\\n * @package tagger\\n *\\/\\n\\n\\/** @var Tagger $tagger *\\/\\n$tagger = $modx->getService(\'tagger\', \'Tagger\', $modx->getOption(\'tagger.core_path\', null, $modx->getOption(\'core_path\') . \'components\\/tagger\\/\') . \'model\\/tagger\\/\', $scriptProperties);\\nif (!($tagger instanceof Tagger))\\n    return \'\';\\n\\n$resources = $modx->getOption(\'resources\', $scriptProperties, is_object($modx->resource) ? $modx->resource->get(\'id\') : \'\');\\n$groups = $modx->getOption(\'groups\', $scriptProperties, \'\');\\n$showUnused = (int)$modx->getOption(\'showUnused\', $scriptProperties, \'0\');\\n$showUnpublished = (int)$modx->getOption(\'showUnpublished\', $scriptProperties, \'0\');\\n$showDeleted = (int)$modx->getOption(\'showDeleted\', $scriptProperties, \'0\');\\n$contexts = $modx->getOption(\'contexts\', $scriptProperties, \'\');\\n\\n$totalPh = $modx->getOption(\'totalPh\', $scriptProperties, \'tags_total\');\\n\\n$resources = $tagger->explodeAndClean($resources);\\n$groups = $tagger->explodeAndClean($groups);\\n$contexts = $tagger->explodeAndClean($contexts);\\n\\n$c = $modx->newQuery(\'TaggerTag\');\\n\\n$c->leftJoin(\'TaggerTagResource\', \'Resources\');\\n$c->leftJoin(\'TaggerGroup\', \'Group\');\\n$c->leftJoin(\'modResource\', \'Resource\', array(\'Resources.resource = Resource.id\'));\\n\\n\\nif (!empty($contexts)) {\\n    $c->where(array(\'Resource.context_key:IN\' => $contexts, ));\\n}\\n\\nif ($showUnpublished == 0) {\\n    $c->where(array(\\n        \'Resource.published\' => 1,\\n        \'OR:Resource.published:IN\' => null,\\n        ));\\n}\\n\\nif ($showDeleted == 0) {\\n    $c->where(array(\\n        \'Resource.deleted\' => 0,\\n        \'OR:Resource.deleted:IS\' => null,\\n        ));\\n}\\n\\nif ($showUnused == 0) {\\n    $c->having(array(\'cnt > 0\', ));\\n}\\n\\nif ($resources) {\\n    $c->where(array(\'Resources.resource:IN\' => $resources));\\n}\\n\\nif ($groups) {\\n    $c->where(array(\\n        \'Group.id:IN\' => $groups,\\n        \'OR:Group.name:IN\' => $groups,\\n        \'OR:Group.alias:IN\' => $groups,\\n        ));\\n}\\n$c->select($modx->getSelectColumns(\'TaggerTag\', \'TaggerTag\'));\\n\\/\\/$c->select($modx->getSelectColumns(\'TaggerGroup\', \'Group\', \'group_\'));\\n$c->select(array(\'cnt\' => \'COUNT(Resources.tag)\'));\\n$c->groupby($modx->getSelectColumns(\'TaggerTag\', \'TaggerTag\') . \',\' . $modx->getSelectColumns(\'TaggerGroup\', \'Group\'));\\n\\n$c->prepare();\\n$countQuery = new xPDOCriteria($modx, \\"SELECT COUNT(*) FROM ({$c->toSQL(false)}) cq\\", $c->bindings, $c->cacheFlag);\\n$stmt = $countQuery->prepare();\\nif ($stmt && $stmt->execute()) {\\n    $total = intval($stmt->fetchColumn());\\n} else {\\n    $total = 0;\\n}\\n\\n$modx->setPlaceholder($totalPh, $total);\\n\\n$tags = array();\\n\\nif ($collection = $modx->getIterator(\'TaggerTag\', $c)) {\\n    foreach ($collection as $tag) {\\n        $tags[] = $tag->get(\'alias\');\\n    }\\n}\\n\\n$wherecondition = array(\'id:not IN\' => $resources);\\n\\n$scriptProperties[\'where\'] = $modx->toJson($wherecondition);\\n\\n$output = \'{\\"template\\":\\"99999999\\"}\';\\n\\nif (count($tags)) {\\n    $scriptProperties[\'tags\'] = implode(\',\', $tags);\\n    $output = $modx->runSnippet(\'TaggerGetResourcesWhere\', $scriptProperties);\\n}\\n\\nreturn $output;"}',
        'guid' => '03fb99a19384196d9f4330948a1be6c7',
        'native_key' => NULL,
        'signature' => 'b188b64776ec6bdc46eaa4d36be694cc',
      ),
      '807895c1cf1bc9a5b56d45ac274bfccc' => 
      array (
        'preserve_keys' => false,
        'update_object' => true,
        'unique_key' => 'name',
        'class' => 'modSnippet',
        'object' => '{"id":null,"source":0,"property_preprocess":0,"name":"TaggerGetCurrentTag","description":"","editor_type":0,"category":0,"cache_type":0,"snippet":"\\/**\\n * TaggerGetCurrentTag\\n *\\n * DESCRIPTION\\n *\\n *\\n * PROPERTIES:\\n *\\n * &tagTpl          string      optional    Name of a chunk that will be used for each Tag. If no chunk is given, array with available placeholders will be rendered\\n * &groupTpl        string      optional    Name of a chunk that will be used for each Group. If no chunk is given, array with available placeholders will be rendered\\n * &outTpl          string      optional    Name of a chunk that will be used for wrapping all groups. If no chunk is given, tags will be rendered without a wrapper\\n * &tagSeparator    string      optional    String separator, that will be used for separating Tags\\n * &groupSeparator  string      optional    String separator, that will be used for separating Groups\\n * &target          int         optional    An ID of a resource that will be used for generating URI for a Tag. If no ID is given, current Resource ID will be used\\n * &friendlyURL     int         optional    If set, will be used instead of friendly_urls system setting to generate URL\\n * &linkTagScheme   int|string  optional    Strategy to generate URLs, available values: -1, 0, 1, full, abs, http, https; Default: link_tag_scheme system setting\\n *\\n * USAGE:\\n *\\n * [[!TaggerGetCurrentTag? &groupTpl=`currentGroup` &tagTpl=`@INLINE [[+tag]]` &tagSeparator=`, ` ]]\\n *\\n *\\n * @package tagger\\n *\\/\\n\\n\\/** @var Tagger $tagger *\\/\\n$tagger = $modx->getService(\'tagger\', \'Tagger\', $modx->getOption(\'tagger.core_path\', null, $modx->getOption(\'core_path\') . \'components\\/tagger\\/\') . \'model\\/tagger\\/\', $scriptProperties);\\nif (!($tagger instanceof Tagger))\\n    return \'\';\\n\\n$target = (int) $modx->getOption(\'target\', $scriptProperties, $modx->resource->id, true);\\n$tagTpl = $modx->getOption(\'tagTpl\', $scriptProperties, \'\');\\n$groupTpl = $modx->getOption(\'groupTpl\', $scriptProperties, \'\');\\n$outTpl = $modx->getOption(\'outTpl\', $scriptProperties, \'\');\\n$tagSeparator = $modx->getOption(\'tagSeparator\', $scriptProperties, \'\');\\n$groupSeparator = $modx->getOption(\'groupSeparator\', $scriptProperties, \'\');\\n\\n$friendlyURL = (int) $modx->getOption(\'friendlyURL\', $scriptProperties, $modx->getOption(\'friendly_urls\', null, 0));\\n$linkTagScheme = $modx->getOption(\'linkTagScheme\', $scriptProperties, $modx->getOption(\'link_tag_scheme\', null, -1));\\n\\n$currentTags = $tagger->getCurrentTags();\\n$currentTagsLink = array();\\n\\nforeach($currentTags as $currentTag) {\\n    $currentTagsLink[$currentTag[\'alias\']] = array_keys($currentTag[\'tags\']);\\n}\\n\\n$output = array();\\n\\nforeach ($currentTags as $currentTag) {\\n    if (!isset($currentTag[\'tags\'])) continue;\\n\\n    $tags = array();\\n\\n    foreach ($currentTag[\'tags\'] as $tag) {\\n        $linkData = $currentTags;\\n        unset($linkData[$currentTag[\'alias\']][\'tags\'][$tag[\'alias\']]);\\n        if (count($linkData[$currentTag[\'alias\']][\'tags\']) === 0) {\\n            unset($linkData[$currentTag[\'alias\']]);    \\n        }\\n\\n        if ($friendlyURL === 1) {\\n            $linkPath = array_reduce(array_keys($linkData), function($carry, $item) use ($linkData) {\\n                return $carry . $item . \'\\/\' . implode(\'\\/\', array_unique(array_keys($linkData[$item][\'tags\']))) . \'\\/\';\\n            }, \'\');\\n    \\n            $uri = rtrim($modx->makeUrl($target, \'\', \'\', $linkTagScheme), \'\\/\') . \'\\/\' . $linkPath;\\n        } else {\\n            $args = [];\\n            foreach ($linkData as $group) {\\n                $args[$group[\'alias\']] = implode(\',\', array_keys($group[\'tags\']));  \\n            }\\n\\n            $uri = $modx->makeUrl($target, \'\', $args, $linkTagScheme);\\n        }\\n        \\n        $phs = array (\\n            \'tag\' => $tag[\'tag\'],\\n            \'label\' => $tag[\'label\'],\\n            \'alias\' => $tag[\'alias\'],\\n            \'uri\' => $uri,\\n            \'group_name\' => $currentTag[\'group\'],\\n            \'group_alias\' => $currentTag[\'alias\'],\\n        );\\n\\n        if (empty($tagTpl)) {\\n            $tags[] = \'<pre>\' . print_r($phs, true) . \'<\\/pre>\';\\n        } else {\\n            $tags[] = $tagger->getChunk($tagTpl, $phs);\\n        }\\n    }\\n\\n    $groupPhs = array(\\n        \'name\' => $currentTag[\'group\'],\\n        \'alias\' => $currentTag[\'alias\'],\\n        \'multipleTags\' => intval(count($tags) > 1),\\n        \'tags\' => implode($tagSeparator, $tags)\\n    );\\n\\n    if (empty($groupTpl)) {\\n        $output[] = \'<pre>\' . print_r($groupPhs, true) . \'<\\/pre>\';\\n    } else {\\n        $output[] = $tagger->getChunk($groupTpl, $groupPhs);\\n    }\\n}\\n\\nif (!empty($outTpl) && !empty($output)) {\\n    return $tagger->getChunk($outTpl, array(\\n        \'groups\' => implode($groupSeparator, $output)\\n    ));\\n}\\n\\nreturn implode($groupSeparator, $output);","locked":0,"properties":"a:0:{}","moduleguid":"","static":0,"static_file":"","content":"\\/**\\n * TaggerGetCurrentTag\\n *\\n * DESCRIPTION\\n *\\n *\\n * PROPERTIES:\\n *\\n * &tagTpl          string      optional    Name of a chunk that will be used for each Tag. If no chunk is given, array with available placeholders will be rendered\\n * &groupTpl        string      optional    Name of a chunk that will be used for each Group. If no chunk is given, array with available placeholders will be rendered\\n * &outTpl          string      optional    Name of a chunk that will be used for wrapping all groups. If no chunk is given, tags will be rendered without a wrapper\\n * &tagSeparator    string      optional    String separator, that will be used for separating Tags\\n * &groupSeparator  string      optional    String separator, that will be used for separating Groups\\n * &target          int         optional    An ID of a resource that will be used for generating URI for a Tag. If no ID is given, current Resource ID will be used\\n * &friendlyURL     int         optional    If set, will be used instead of friendly_urls system setting to generate URL\\n * &linkTagScheme   int|string  optional    Strategy to generate URLs, available values: -1, 0, 1, full, abs, http, https; Default: link_tag_scheme system setting\\n *\\n * USAGE:\\n *\\n * [[!TaggerGetCurrentTag? &groupTpl=`currentGroup` &tagTpl=`@INLINE [[+tag]]` &tagSeparator=`, ` ]]\\n *\\n *\\n * @package tagger\\n *\\/\\n\\n\\/** @var Tagger $tagger *\\/\\n$tagger = $modx->getService(\'tagger\', \'Tagger\', $modx->getOption(\'tagger.core_path\', null, $modx->getOption(\'core_path\') . \'components\\/tagger\\/\') . \'model\\/tagger\\/\', $scriptProperties);\\nif (!($tagger instanceof Tagger))\\n    return \'\';\\n\\n$target = (int) $modx->getOption(\'target\', $scriptProperties, $modx->resource->id, true);\\n$tagTpl = $modx->getOption(\'tagTpl\', $scriptProperties, \'\');\\n$groupTpl = $modx->getOption(\'groupTpl\', $scriptProperties, \'\');\\n$outTpl = $modx->getOption(\'outTpl\', $scriptProperties, \'\');\\n$tagSeparator = $modx->getOption(\'tagSeparator\', $scriptProperties, \'\');\\n$groupSeparator = $modx->getOption(\'groupSeparator\', $scriptProperties, \'\');\\n\\n$friendlyURL = (int) $modx->getOption(\'friendlyURL\', $scriptProperties, $modx->getOption(\'friendly_urls\', null, 0));\\n$linkTagScheme = $modx->getOption(\'linkTagScheme\', $scriptProperties, $modx->getOption(\'link_tag_scheme\', null, -1));\\n\\n$currentTags = $tagger->getCurrentTags();\\n$currentTagsLink = array();\\n\\nforeach($currentTags as $currentTag) {\\n    $currentTagsLink[$currentTag[\'alias\']] = array_keys($currentTag[\'tags\']);\\n}\\n\\n$output = array();\\n\\nforeach ($currentTags as $currentTag) {\\n    if (!isset($currentTag[\'tags\'])) continue;\\n\\n    $tags = array();\\n\\n    foreach ($currentTag[\'tags\'] as $tag) {\\n        $linkData = $currentTags;\\n        unset($linkData[$currentTag[\'alias\']][\'tags\'][$tag[\'alias\']]);\\n        if (count($linkData[$currentTag[\'alias\']][\'tags\']) === 0) {\\n            unset($linkData[$currentTag[\'alias\']]);    \\n        }\\n\\n        if ($friendlyURL === 1) {\\n            $linkPath = array_reduce(array_keys($linkData), function($carry, $item) use ($linkData) {\\n                return $carry . $item . \'\\/\' . implode(\'\\/\', array_unique(array_keys($linkData[$item][\'tags\']))) . \'\\/\';\\n            }, \'\');\\n    \\n            $uri = rtrim($modx->makeUrl($target, \'\', \'\', $linkTagScheme), \'\\/\') . \'\\/\' . $linkPath;\\n        } else {\\n            $args = [];\\n            foreach ($linkData as $group) {\\n                $args[$group[\'alias\']] = implode(\',\', array_keys($group[\'tags\']));  \\n            }\\n\\n            $uri = $modx->makeUrl($target, \'\', $args, $linkTagScheme);\\n        }\\n        \\n        $phs = array (\\n            \'tag\' => $tag[\'tag\'],\\n            \'label\' => $tag[\'label\'],\\n            \'alias\' => $tag[\'alias\'],\\n            \'uri\' => $uri,\\n            \'group_name\' => $currentTag[\'group\'],\\n            \'group_alias\' => $currentTag[\'alias\'],\\n        );\\n\\n        if (empty($tagTpl)) {\\n            $tags[] = \'<pre>\' . print_r($phs, true) . \'<\\/pre>\';\\n        } else {\\n            $tags[] = $tagger->getChunk($tagTpl, $phs);\\n        }\\n    }\\n\\n    $groupPhs = array(\\n        \'name\' => $currentTag[\'group\'],\\n        \'alias\' => $currentTag[\'alias\'],\\n        \'multipleTags\' => intval(count($tags) > 1),\\n        \'tags\' => implode($tagSeparator, $tags)\\n    );\\n\\n    if (empty($groupTpl)) {\\n        $output[] = \'<pre>\' . print_r($groupPhs, true) . \'<\\/pre>\';\\n    } else {\\n        $output[] = $tagger->getChunk($groupTpl, $groupPhs);\\n    }\\n}\\n\\nif (!empty($outTpl) && !empty($output)) {\\n    return $tagger->getChunk($outTpl, array(\\n        \'groups\' => implode($groupSeparator, $output)\\n    ));\\n}\\n\\nreturn implode($groupSeparator, $output);"}',
        'guid' => 'ff669d7a791dd0b51b25df15d4d71055',
        'native_key' => NULL,
        'signature' => '7f8962fa9a9d7623121a359e954e42b0',
      ),
    ),
    'Plugins' => 
    array (
      'd92f2f86865ea9be36641815ffa453e3' => 
      array (
        'unique_key' => 'name',
        'preserve_keys' => false,
        'update_object' => true,
        'related_objects' => 
        array (
          'PluginEvents' => 
          array (
            'd9665e343c9941a2ee9e09a093da0fa0' => 
            array (
              'class' => 'modPluginEvent',
              'object' => '{"pluginid":0,"event":"OnDocFormSave","priority":0,"propertyset":0}',
              'guid' => '140dc8e1266340f198ea4d7dc82daa0b',
              'native_key' => 
              array (
                0 => 0,
                1 => 'OnDocFormSave',
              ),
              'signature' => '56aad0ff9ca0b7204609d4880960116d',
            ),
            '0615581e30c07c8a3d634b1c9e096204' => 
            array (
              'class' => 'modPluginEvent',
              'object' => '{"pluginid":0,"event":"OnDocFormPrerender","priority":0,"propertyset":0}',
              'guid' => '2c7f0644916325475906acbeebd7d28c',
              'native_key' => 
              array (
                0 => 0,
                1 => 'OnDocFormPrerender',
              ),
              'signature' => '0e874bf5456a947487e7f22eb75b71de',
            ),
            '5fef860c97f2e29a4827263a59f86e5b' => 
            array (
              'class' => 'modPluginEvent',
              'object' => '{"pluginid":0,"event":"OnPageNotFound","priority":0,"propertyset":0}',
              'guid' => '7ab281a613b95752ad207113ec5680c6',
              'native_key' => 
              array (
                0 => 0,
                1 => 'OnPageNotFound',
              ),
              'signature' => '9e04e9a003628d2d9cfd11679b96e2a9',
            ),
            'd96fa4d211b480d8f7e9352a74c95b32' => 
            array (
              'class' => 'modPluginEvent',
              'object' => '{"pluginid":0,"event":"OnResourceDuplicate","priority":0,"propertyset":0}',
              'guid' => 'd1170e05b589b11eaa78e6b86101a314',
              'native_key' => 
              array (
                0 => 0,
                1 => 'OnResourceDuplicate',
              ),
              'signature' => 'cb9a4ef016a2ba09d37d0f7b1d038861',
            ),
          ),
        ),
        'related_object_attributes' => 
        array (
          'PluginEvents' => 
          array (
            'preserve_keys' => true,
            'update_object' => false,
            'unique_key' => 
            array (
              0 => 'pluginid',
              1 => 'event',
            ),
          ),
        ),
        'class' => 'modPlugin',
        'object' => '{"id":null,"source":0,"property_preprocess":0,"name":"Tagger","description":"","editor_type":0,"category":0,"cache_type":0,"plugincode":"\\/**\\n * Tagger\\n *\\n * DESCRIPTION\\n *\\n * This plugin inject JS to add Tab with tag groups into Resource panel\\n *\\/\\n\\n$corePath = $modx->getOption(\'tagger.core_path\', null, $modx->getOption(\'core_path\', null, MODX_CORE_PATH) . \'components\\/tagger\\/\');\\n\\/** @var Tagger $tagger *\\/\\n$tagger = $modx->getService(\\n    \'tagger\',\\n    \'Tagger\',\\n    $corePath . \'model\\/tagger\\/\',\\n    array(\\n        \'core_path\' => $corePath\\n    )\\n);\\n\\n$className = \'Tagger\' . $modx->event->name;\\n$modx->loadClass(\'TaggerPlugin\', $tagger->getOption(\'modelPath\') . \'tagger\\/events\\/\', true, true);\\n$modx->loadClass($className, $tagger->getOption(\'modelPath\') . \'tagger\\/events\\/\', true, true);\\n\\nif (class_exists($className)) {\\n    \\/** @var TaggerPlugin $handler *\\/\\n    $handler = new $className($modx, $scriptProperties);\\n    $handler->run();\\n}\\n\\nreturn;","locked":0,"properties":"a:0:{}","disabled":0,"moduleguid":"","static":0,"static_file":"","content":"\\/**\\n * Tagger\\n *\\n * DESCRIPTION\\n *\\n * This plugin inject JS to add Tab with tag groups into Resource panel\\n *\\/\\n\\n$corePath = $modx->getOption(\'tagger.core_path\', null, $modx->getOption(\'core_path\', null, MODX_CORE_PATH) . \'components\\/tagger\\/\');\\n\\/** @var Tagger $tagger *\\/\\n$tagger = $modx->getService(\\n    \'tagger\',\\n    \'Tagger\',\\n    $corePath . \'model\\/tagger\\/\',\\n    array(\\n        \'core_path\' => $corePath\\n    )\\n);\\n\\n$className = \'Tagger\' . $modx->event->name;\\n$modx->loadClass(\'TaggerPlugin\', $tagger->getOption(\'modelPath\') . \'tagger\\/events\\/\', true, true);\\n$modx->loadClass($className, $tagger->getOption(\'modelPath\') . \'tagger\\/events\\/\', true, true);\\n\\nif (class_exists($className)) {\\n    \\/** @var TaggerPlugin $handler *\\/\\n    $handler = new $className($modx, $scriptProperties);\\n    $handler->run();\\n}\\n\\nreturn;"}',
        'guid' => 'bd506708949c63f1c0a5768db6a9d730',
        'native_key' => NULL,
        'signature' => 'd6d3419804e32071631d76bb89f93ea0',
      ),
    ),
  ),
  'related_object_attributes' => 
  array (
    'Children' => 
    array (
      'preserve_keys' => false,
      'update_object' => true,
      'unique_key' => 
      array (
        0 => 'parent',
        1 => 'category',
      ),
    ),
    'Snippets' => 
    array (
      'preserve_keys' => false,
      'update_object' => true,
      'unique_key' => 'name',
    ),
    'Chunks' => 
    array (
      'preserve_keys' => false,
      'update_object' => true,
      'unique_key' => 'name',
    ),
    'Templates' => 
    array (
      'preserve_keys' => false,
      'update_object' => true,
      'unique_key' => 'templatename',
    ),
    'TemplateVars' => 
    array (
      'preserve_keys' => false,
      'update_object' => true,
      'unique_key' => 'name',
    ),
    'Plugins' => 
    array (
      'unique_key' => 'name',
      'preserve_keys' => false,
      'update_object' => true,
      'related_objects' => true,
      'related_object_attributes' => 
      array (
        'PluginEvents' => 
        array (
          'preserve_keys' => true,
          'update_object' => false,
          'unique_key' => 
          array (
            0 => 'pluginid',
            1 => 'event',
          ),
        ),
      ),
    ),
  ),
  'namespace' => 'tagger',
  'resolve' => 
  array (
    0 => 
    array (
      'type' => 'php',
      'body' => '{"source":"tagger-1.11.0-pl\\/modCategory\\/31d07c9228a7d4138a2b04c3e0964d05.resolve.remove_tables.resolver","type":"php","name":"resolve.remove_tables"}',
    ),
    1 => 
    array (
      'type' => 'file',
      'body' => '{"source":"tagger-1.11.0-pl\\/modCategory\\/31d07c9228a7d4138a2b04c3e0964d05\\/1\\/","target":"return MODX_ASSETS_PATH . \'components\\/\';","name":"tagger"}',
    ),
    2 => 
    array (
      'type' => 'file',
      'body' => '{"source":"tagger-1.11.0-pl\\/modCategory\\/31d07c9228a7d4138a2b04c3e0964d05\\/2\\/","target":"return MODX_CORE_PATH . \'components\\/\';","name":"tagger"}',
    ),
    3 => 
    array (
      'type' => 'php',
      'body' => '{"source":"tagger-1.11.0-pl\\/modCategory\\/31d07c9228a7d4138a2b04c3e0964d05.gpm.resolve.tables.resolver","type":"php","name":"gpm.resolve.tables"}',
    ),
    4 => 
    array (
      'type' => 'php',
      'body' => '{"source":"tagger-1.11.0-pl\\/modCategory\\/31d07c9228a7d4138a2b04c3e0964d05.resolve.synctables.resolver","type":"php","name":"resolve.synctables"}',
    ),
    5 => 
    array (
      'type' => 'php',
      'body' => '{"source":"tagger-1.11.0-pl\\/modCategory\\/31d07c9228a7d4138a2b04c3e0964d05.resolve.tables.resolver","type":"php","name":"resolve.tables"}',
    ),
    6 => 
    array (
      'type' => 'php',
      'body' => '{"source":"tagger-1.11.0-pl\\/modCategory\\/31d07c9228a7d4138a2b04c3e0964d05.resolve.settings.resolver","type":"php","name":"resolve.settings"}',
    ),
  ),
  'validate' => NULL,
  'vehicle_package' => 'transport',
  'vehicle_class' => 'xPDOObjectVehicle',
  'guid' => 'c4c3b4fc5f18f9b2b3cac48092b70971',
  'package' => 'modx',
  'class' => 'modCategory',
  'signature' => '31d07c9228a7d4138a2b04c3e0964d05',
  'native_key' => NULL,
  'object' => '{"id":null,"parent":0,"category":"Tagger","rank":0}',
);